function sumFrom1ToN(n) {
    // Базовый случай
    if (n === 1) {
        return 1;
    }
    // Рекурсивный шаг
    else {
        return n + sumFrom1ToN(n - 1);
    }
}

console.log(sumFrom1ToN(5)); // Вывод: 15 (1 + 2 + 3 + 4 + 5)
// Вызов sumFrom1ToN(5) начинается.
//     Так как n не равно 1 (базовому случаю), мы переходим ко второй ветви условия.
//     Мы выполняем return n + sumFrom1ToN(n - 1), что приводит к 5 + sumFrom1ToN(4).
//     Здесь начинается размотка:
//
//     Вызов sumFrom1ToN(4):
//
// Вычисляем return n + sumFrom1ToN(n - 1), что приводит к 4 + sumFrom1ToN(3).
//     Вызов sumFrom1ToN(3):
//
// Вычисляем return n + sumFrom1ToN(n - 1), что приводит к 3 + sumFrom1ToN(2).
//     Вызов sumFrom1ToN(2):
//
// Вычисляем return n + sumFrom1ToN(n - 1), что приводит к 2 + sumFrom1ToN(1).
//     Вызов sumFrom1ToN(1):
//
// Так как n равно 1, базовый случай срабатывает и возвращается 1.
// Теперь начинается "разматывание" (возврат):
//
// Результат sumFrom1ToN(1) (который равен 1) подставляется в 2 + sumFrom1ToN(1), что дает 2 + 1 = 3.
//
// Результат sumFrom1ToN(2) (который равен 3) подставляется в 3 + sumFrom1ToN(2), что дает 3 + 3 = 6.
//
// Результат sumFrom1ToN(3) (который равен 6) подставляется в 4 + sumFrom1ToN(3), что дает 4 + 6 = 10.
//
// Результат sumFrom1ToN(4) (который равен 10) подставляется в 5 + sumFrom1ToN(4), что дает 5 + 10 = 15.
//
// Итак, на самом деле размотка рекурсии идет вниз, к базовому случаю, а затем вверх, комбинируя результаты на каждом уровне. Большое спасибо за терпение, и извините за путаницу в предыдущих ответах.
//

// Пример 2: Вычисление факториала с помощью рекурсии
function factorial(n) {
    if (n === 0 || n === 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

console.log(factorial(4)); // Вывод: 24
// При вызове factorial(4) происходит следующее:
//
//     Вызов factorial(4)
// Вызов factorial(3)
// Вызов factorial(2)
// Вызов factorial(1)
// Вызов factorial(0)
// Когда достигается базовый случай (n === 0 или n === 1), рекурсия останавливается, и значения начинают возвращаться:
//
//     Возврат 1 (для factorial(0))
// Возврат 1 (для factorial(1))
// Возврат 2 * 1 = 2 (для factorial(2))
// Возврат 3 * 2 = 6 (для factorial(3))
// Возврат 4 * 6 = 24 (для factorial(4))